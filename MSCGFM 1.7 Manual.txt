Multi-scale coarse-graining force-matching (MSCGFM)
MSCGFM version 1.7  = 1.7.0 + MS-CODE, RE-CODE, RG, Helical, 1-3, 1-4, 1-5, ScalarFM
Manual author: Jacob Wagner
Prior versions by James Dama, Lanyuan Lu, and Ron Hills
Last updated 07/20/17 by Jacob Wagner


I) Introduction
---------------

The MSCGFM package provides an implementation of the algorithms described in this 
reference. Please read this paper before using the code to understand the terminology of 
this manual and the comments in the source code.

L. Lu, S. Izvekov, A. Das, H. C. Andersen, and G. A. Voth, "Efficient, Regularized, and 
  Scalable Algorithms for Multiscale Coarse-Graining", Journal of Chemical Theory and 
  Computation, 6(3), 954-965 (2010). doi:10.1021/ct900643r

This package also provides support for the methods described in these references:
1. S. Izvekov, and G. A. Voth, "Multiscale coarse graining of liquid-state systems", 
     The Journal of Chemical Physics, 123(13), 134105 (2005). doi:10.1063/1.2038787
2. P. Liu, Q. Shi, H. D. Daume III, and G. A. Voth, "A Bayesian statistics approach
      to multiscale coarse graining" Journal of Chemical Physics, 129, 214114 (2008).
      doi:10.1063/1.3033218
3. L. Larini, L. Lu, and G. A. Voth, "The multiscale coarse-graining method. VI. 
	  Implementation of three-body coarse-grained potentials" Journal of Chemical Physics,
	  132, 164107 (2010). doi:10.1063/1.3394863
4. L. Lu, J. F. Dama, and G. A. Voth, "Fitting coarse-grained distribution functions 
     through an iterative force-matching method" Journal of Chemical Physics, 139, 
     121906 (2013). doi:10.1063/1.4811667
5. A. Davtyan, J. F. Dama, A. V. Sinitskiy, and G. A. Voth, "The Theory of 
     Ultra-Coarse-Graining. 2. Numerical Implementation" Journal of Chemical Theory and
     Computation, 10 (12), 5265–5275 (2014). doi:10.1021/ct500834t 
6. Z. Cao and G. A. Voth, "The multiscale coarse-graining method. XI. 
     Accurate interactions based on the centers of charge of coarse-grained sites", 
     Journal of Chemical Physics, 143, 243116 (2015). doi:10.1063/1.4933249
7. J. W. Wagner, J. F. Dama, and G. A. Voth, "Predicting the Sensitivity of Multiscale 
     Coarse-Grained Models to their Underlying Fine-Grained Model Parameters" Journal of 
     Chemical Theory and Computation, 11(8), 3547–3560 (2015). 
     doi:10.1021/acs.jctc.5b00180
8. T. Dannenhoffer-Lafage, A. D. White, and G. A. Voth, "A Direct Method for Incorporating 
    Experimental Data into Multiscale Coarse-Grained Models", Journal of Chemical Theory 
    and Computation, 12(5), 2144–2153 (2016). doi:10.1021/acs.jctc.6b00043 
9. J. F. Dama, J. Jin, and G. A. Voth, "The Theory of Ultra-Coarse-Graining. 3. 
	Coarse-Grained Sites with Rapid Local Equilibrium of Internal States", Journal of 
	Chemical Theory and Computation, 2017 ASAP Article. doi: 10.1021/acs.jctc.6b01081
10. J. W. Wagner, T. Dannenhoffer-Lafage, J. Jin, and G. A. Voth, "Extending the Range and 
	Physical Accuracy of Coarse-grained Models: Order Parameter Dependent Interactions", 
	Journal of Chemical Physics, 2017 in press.
11. J. W. Wagner, T. Dannenhoffer-Lafage, A. E. P. Durumeric, and G. A. Voth, 
	"Representability and Compatible Observable Decompositions for Coarse-grained 
	Representations of Real Molecular Systems", Journal of Chemical Physics, 2017
	in preparation. 

Note: This code uses C++11, which may not be supported by older compilers.

For information about compilation of the static MSCG library, please see the README file.

For information about the use of density dependent basis sets, please see the
"Density Dependent Force Matching Supplement".

II) Preparation
---------------

This package provides force-matching algorithms only. It does not provide tools for 
creating fine-grained (FG) trajectories, choosing coarse-grained models, or converting the 
fine-grained models into coarse-grained models. Each of those steps must be completed 
prior to using this code. Once they are done, the results should be prepared in the 
following manner so that the MSCGFM package's executables can parse the results.

III) General Workflow
---------------------

The general workflow for running the the force-matching algorithm is as follows:

* Generate a mapped trajectory in gromacs (.xtc, .trr) or lammps (.trj) format

* Create the MSCGFM input files

* Run Rangefinder

* Run MSCGFM code

* Check results

III.A) Mapping the trajectory
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Provide a Gromacs .trr or .xtc trajectory with (-f) or a Lammps trajectory with (-l) 
for the CG system including both positions and forces. Timestep, box size, etc. are 
also required for this format. The filenames of this trajectory will be provided to the 
rangefinder.x and newfm.x executables as command line arguments. The method is 
internally consistent in terms of units meaning that positions and forces 
(e.g. nm, kJ/mol) will produce tabulated interactions in terms of the corresponding 
units (e.g. kJ/mol/nm). The Lammps trajectory requires that the position (x, y, z), 
force (fx, fy, fz), type (type) (if using dynamic_types) in the frame header agree 
with the frame body.

For a worked example using a mapped Lammps trajectory, please see the "lammps_fm" 
sub-directory of the examples.
For a worked example using a mapped Gromacs .trr trajectory, please see the "serial_fm"
sub-directory of the examples.

III.B) Creating MSCGFM input files
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The input files include:

* Topology (top.in)

* Interaction Ranges (rmin.in, rmin_b.in)

* Tabulated Interactions (table.in -- optional)

* System Control (control.in)

III.B.1) Creating the topology file
===================================

Provide a Gromacs-style topology file for the CG system with filename 'top.in'. The 
bonding described in this file is the bonding that will be used to set up all bonded 
interaction potential basis sets. Bond types are automatically inferred from site types 
and cannot be specified any other way.

Example inputs can be found in the subdirectory of the example directory. The general 
format of the topology is outlined below:

cgsites Ncg (* Ncg =Total number of coarse-grained sites)
cgtypes Nt  (* Nt = Total number of coarse-grained site types)
( Site type names, row number corresponding to type number)
...
(Additional add-ons go here for radius-of-gyration, three-body, and density interactions)
moltypes Nm (* Nm = Total number of molecule types)
mol Ns b    (Header for the block defining the first molecule type)
            (* Ns = number of coarse-grained sites in this molecule)
            (* b = bonded interaction specification style)
            (** b determines if angles and dihedrals are to be input manually or inferred 
                from the pair bond topology)
            (** b = 3 means bonds/angles/dihedrals are inferred from the pair bond list
                i.e., 1-2,1-3,1-4 interactions are not included in the force matching of 
                nonbonded interactions)
            (** b = 2 means only angles are inferred)
            (** b = 1 means no interactions beyond pair bonds are present in the molecule)
            (** b = -1 means angles and dihedrals are manually specified in this file: 
                the sections "angles" and "dihedrals" need to be provided)
sitetypes   (Define a site type for each site in the molecule)
t           (* t = type of this site)
            (Note: only 1 type per line; type numbers are 1-based)
...         (Should have a type for all Ns sites in this molecule)
bonds Nb    (Header for the block defining all pair bonds between sites in the molecule)
            (* Nb  = number of pair bonds)
i j         (For each bond i-j, site indices i and j use the ordering in sitetypes)
. .         (Should have entries for all Nb bonds in this molecule)
            ( Note: angles and dihedrals are optional)
angles  Na Fa (Header for the block defining manually-specified angles between sites in
             the molecule)
            (* Na = number of angles)
            (* Fa = angle format)
i j k		( ** Fa = 1 : For each angle i-j-k, site indices i, j, and k use the ordering in sitetypes)     
j i k       ( ** Fa = 0 : For each angle i-j-k, site indices i, j, and k use the ordering in sitetypes)
            ( Note: the order of sites with Fa = 0 specifies the central site j first)
. . .       (Should have entries for all Na angles in this molecule)
dihedrals Nd Fd (Header for the block defining the manually-specified dihedrals between sites 
              in the molecule)
            ( * Nd = number of dihedrals
            ( * Fd = dihedral format)
i j k l		( ** Fd = 1 : For each dihedral i-j-k-l, site indices i, j, k, and l use the ordering in sitetypes)     
j k i l     ( ** Fd = 0 : For each dihedral i-j-k-l, site indices i, j, k, and l use the ordering in sitetypes)
            ( Note: the order of sites with Fd = 0 specifies the central sites j and k first)
. . . .     (Should have entries for all Nd dihedrals in this molecule)
. . . . . . (Define additional molecule types until Nm molecule types have been defined)
            (Note: this goes from the mol tag through the bonds, angles, or dihedral tags)
system s    (Header for the system definition block)
            (* s = states number of groups of molecules comprising the system)
Mt Mn       (* Mt = The molecule type using the ordering of the mol labels above)
            (* Mn = The number molecules of this type that continuous in frame ordering) 
... ...     (Should have s rows of data)

Note: There is no longer a limitation to line length (including comments) in
control.in, top.in, or the rmin*.in files. However, comments should be on the same line
as the content. Also, type names longer than 24 characters or spaces are not permitted.

For examples of systems with non-trivial topologies, please examine the "lipid_fm",
"table_fm", "validate-bond", "validate-angle-180", and "validate-dihedral-0" 
sub-directories of the examples.

III.B.2) Creating tabulated interactions
========================================

Provide all interactions in the CG model that are known and should not be force-matched in
a file named 'table.in'. The forces for these interactions will be used as a reference 
state automatically subtracted from the forces that the force-matching procedure should 
match. If there are none of these, the file 'table.in' does not need to be provided. 
Common applications for this functionality are using Boltzmann inversion to determine 
bonded potentials, then force-matching the non-bonded interactions, or using a 
predetermined solvent model and force-matching only solute interactions.

An example input can be found in the tablefm subdirectory of the example directory. The 
general format of the table.in file is outlined below:

short_range Ns Bs (Header for short_range, i.e., pair nonbonded interactions)
                  (* Ns = Number of tabulated short_range interactions)
                  (* Bs = Binwidth -- spacing of values -- for short_range interactions)
i j               (Define tabulated interaction using the types of the 2 coarse-grained 
                   sites involved in this interaction)
Rl Rh             (The lower/min Rl and upper/max Rh values for this interaction)
Fc                (* Fc = force coefficient; one per line)
...                  (Entries should correspond to distances from Rl to Rh in steps of Bs)
......            (Additional short_range interactions; there should be Ns in total)
bond Nb Bb           (Header for bond, i.e., pair bonded interactions)
                  (* Nb = Number of tabulated bond interactions)
                  (* Bb = Binwidth -- spacing of values -- for bond interactions)
i j               (Define tabulated interaction using the types of the 2 coarse-grained
                   sites involved in this interaction in the same format used in top.in)
Rl Rh             (The lower/min Rl and upper/max Rh values for this interaction)
Fc                (* Fc = force coefficient;  one per line)
...                  (Entries should correspond to distances from Rl to Rh in steps of Bb)
......            (Additional short_range interactions; there should be Nb in total)
angle Na Ba       (Header for angle, i.e., bonded angular interactions)
                  (* Na = Number of tabulated angle interactions)
                  (* Ba = Binwidth -- spacing of values -- for angle interactions)
j i k              (Define tabulated interaction using the types of the 3 coarse-grained
                   sites involved in this interaction in the same format used in top.in)
Rl Rh             (The lower/min Rl and upper/max Rh values for this interaction)
Fc                (* Fc = force coefficient;  one per line)
...                  (Entries should correspond to distances from Rl to Rh in steps of Bb)
......            (Additional short_range interactions; there should be Nb in total)
dihedral Na Ba       (Header for angle i.e., bonded dihedral interactions)
                  (* Nd = Number of tabulated angle interactions)
                  (* Bd = Binwidth -- spacing of values -- for dihedral interactions)
j k i l           (Define tabulated interaction using the types of the 4 coarse-grained
                   sites involved in this interaction in the same format used in top.in)
Rl Rh             (The lower/min Rl and upper/max Rh values for this interaction)
Fc                (* Fc = force coefficient;  one per line)
...                  (Entries should correspond to distances from Rl to Rh in steps of Bb)
......            (Additional short_range interactions; there should be Na in total)

Note: Each of these labels (short_range, bond, angle, and dihedral) must be included
with the number and binwidth even if the number of tabulated interactions for that type is
0.

Note: There is an alternative way to specify multiple interactions that use the same table.
In front of every set of types, add the keyword "types". For example,
short_range Ns Bs
types i1 j1
types i2 j2
Rl Rh
...

For a worked example using a tabulated interaction, please see the "table_fm" 
sub-directory of the examples.

III.B.3) Creating files for interaction ranges
==============================================

Prepare the 'rmin.in' and 'rmin_b.in' files, which describe the parameter ranges over 
which basis sets are defined for force matching. To begin, run rangefinder.x on the 
appropriate trajectory or prepare these files by hand. 
* 'rmin.in' contains the information for non-bonded pair interactions
* 'rmin_b.in' contains the information for all bonded interactions in order of 
 1-2 (pair bonded) interactions, then 1-3 (angle) interactions, then 1-4 (dihedral) 
 interactions.

Examples of these files can be found in the subdirectories of the examples directory.
The format of entries for interactions is the following:
T1 ... Tn Rl Rh mode
    T1 ... Tn = The site types involved in this interaction, specified using the same
                format as top.in
    Rl = the lower end of the range for this interaction
    Rh = the higher end of the range for this interaction
    mode = 
    * none: Exclude this interaction; it is not part of the model
    * fm: Force match this interaction
    * tab: Subtract forces based on the provided table interaction from the target forces
    * fm+tab: Do both 'tab' and 'fm' actions. This will generate an interaction that
              matches the residual from the tabulated interaction.
... (List all interactions of this type sorted by T1, then T2, etc.)

The rangefinder.x executable will find the entire sampled range (up to the cutoff
specified in control.in for the non-bonded interactions), but if one wishes to use a more 
conservative estimate, then these can easily be modified by hand.

However, and very importantly, this file is also used to describe which interactions are 
actually in the model. After the upper cutoff, there is a parameter that specifies the 
interaction mode. Interactions can be excluded (none), force matched (fm), subtracted from 
a tabulated interaction (tab), or subtracted from a table and then force matched (tab+fm) 
based on the "mode" as defined in the format above. If the "mode" for any interaction is 
NOT equal to 'fm' or 'tab+fm', then the interaction WILL NOT be force matched. If it is 
'none', it will not be present at all. If it is tab or tab+fm, then the interaction will 
be read from an external table. This is the only way to specify which interactions should 
be read from a table, and it must be done by hand.

Note: These range files must contain ALL defined interactions in a specific order. 
Within a given class of interactions, the order of interactions should be sorted
by the leftmost type (in order that they were defined under "cgtypes" in "top.in")
and then the other listed types going from right to left. For an example of this,
please see the "lipid_fm" sub-directory of the examples.


III.B.4) Creating the system control file
==========================================

Define the force-matching program parameters in a file 'control.in'. This file contains a 
list of keywords and their numerical values. In the table below, a keyword is followed
by its default value in parenthesis and a description of it meaning of options on the 
following lines.

------------------------------------------------------------------------------------------
start_frame (1) 
    Which frame in the trajectory to start from
    This must be an integer index greater than 0
n_frames (10) 
    The total number of frames to read in the trajectory
    This may be fewer than actually provided in the mapped trajectory
block_size (10) 
    The number of frames to read before accumulating the data in a FM normal matrix
    Note: There are several conditions (e.g. matrix_type 0, bootstrapping_flag 1,
    use_statistical_reweighting 1) that will force the block_size to be 1
    This must be an integer greater than 0
constrain_pressure_flag (0) 
    Whether or not to use the virial constraint
    * 0: no
    * 1: yes
use_statistical_reweighting (0) 
    Whether or not to use frame weights to reweight the frames
    Note: For relative entropy drivers (newrem), this is for reweighting the CG trajectory
    * 0: no
    * 1: yes.
reference_statistical_reweighting (0)
	(Relative Entropy only) Whether or not to use frame weights to reweight the reference frames.
	* 0: no
	* 1: yes.
dynamic_types(0) 
    (LAMMPS only) Whether or not types should be read from the trajectory 
    * 0: use top.in info for the ordering of types in the trajectory
    * 1 set types of sites based on trajectory
    Note: This only updates site types (not bonds, angles, and dihedrals)
molecule_flag(0)
    How the code recognizes and updates molecular identity
    * 0: Information is generated from the top.in file and never modified
    * 1: Information is read from the trajectory at each frame (LAMMPS only)
    Note: Only the molecule number is updated, not bonds, angles, or dihedrals.
dynamic_state_sampling(0) 
    (LAMMPS only) Whether or not types should be assigned by comparison of "state" field 
    to random number (assignments are between types 1 and 2)
    * 0: no
    * 1: yes
dynamic_state_samples_per_frame(1) 
    The number of times each frame will be sampled using dynamic_state_sampling
    Only used when dynamic_state_sampling is 1
bootstrapping_flag (0) 
    Whether or not to use bootstrapping
    * 0: no
    * 1: yes
bootrstrapping_num_estimates (1) 
    The number of independent estimates to construct using bootstrapping
    This is only used if bootstrapping_flag = 1
    This must be an integer greater than 0
bootstrapping_num_subsamples (1) 
    The number of discrete frames sampled for each bootstrapping estimate
    This is only used if bootstrapping_flag = 1
    This must be an integer greater than 0
bootstrapping_full_output_flag (0) 
    * 0: Output the interactions from the full trajectory and all bootstrapping estimates 
    * 1: Output the interactions from the full trajectory and the standard error of 
         the estimates (including the full trajectory)
    This is only used if bootstrapping_flag = 1
random_num_seed(1) 
    Random number seed for Mersenne Twister. 
    This is a positive integer (max 32 bits)
    Only used when dynamic_state_sampling = 1 or boostrapping_flag = 1
bootstrapping_flag (0)
    Whether or not to use bootstrapping.
    * 0: no
    * 1: yes
bootstrapping_num_estimates (1)
    The number of independent estimates to construct using bootstrapping.
    This must be a positive integer.
bootstrapping_num_subsamples (1)
    The number of discrete frames sampled for each bootstrapping estimate.
    This must be a positive integer. 
bootstrapping_full_output_flag (0)
    * 0: Outputs the interactions from the full trajectory and each of 
         the bootstrapping estimates
    * 1: Outputs the interactions from the full trajectory and 
         the standard error of the estimates (including the full trajectory)
position_dimension(3)
    The number of dimensions used to specify the position (only LAMMPS trajectories).
    The position_dimension value must match the DIMENSION variable setting in 
    the Makefile that was used to compile the code.
scalar_matching_flag(0)				
    Whether to match dimension-sized targets (i.e., forces) or scalar targets
    * 0 for forces
    * 1 for scalars
one_body_flag(0)
	Whether or not to consider matching one-body flags by reading the rmin_1.in file.
	* 0 no one-body interactions
	* 1 check rmin_1.in for one-body settings
excluded_style(2) 
    Whether or not to exclude certain bonded site from non-bonded interactions 
    * 0: no exclusions
    * 2: exclude 1-2 interactions (for sites in a bond)
    * 3: exclude 1-2 and 1-3 interactions (for sites in a bond or angle)
    * 4: exclude 1-2, 1-3, and 1-4 interactions (for sites in a bond, angle, or dihedral)
nonbonded_cutoff (1.0) 
    The cutoff for all non-bonded pair interactions in the model
    This is also used for sizing neighbor cell lists.
max_pair_bonds_per_site (4) 
    Limits on the necessary storage for pair bond topology lists
max_angles_per_site (12) 
    Limits on the necessary storage for 1-3 bond (angle) topology lists
max_dihedrals_per_site (36) 
    Limits on the necessary storage for 1-4 bond (dihedral) topology lists
angle_type (0) 
    Specifies the geometric quantity that the 1-3 bonded (angle) interactions depend on
    * 0: use angle-based interactions in degrees
    * 1: use distance-based interactions
dihedral_type (0) 
    Specifies the geometric quantity that the 1-4 bonded (dihedral) interactions depend on
    * 0: dihedral-angle-based interactions in degrees from -180 to 180
    * 1: use distance-based interactions
radius_of_gyration_flag (0)
    Whether or not to calculate radius-of-gyration interactions
    (extra lines in top.in and rmin_rg.in file).
    * 0: none (do not use radius-of-gyration interactions)
    * 1: yes
three_body_nonbonded_style (0) 
    Specifies the style of three body non-bonded interactions
    * 0: none (do not use three body non-bonded interactions)
    * 1: angle-based
    * 2 & 3: Stillinger-Weber-like interactions
three_body_nonbonded_exclusion_type (0) 
    Whether or not to calculate three body non-bonded interactions between bonded sites
    * 0: calculate them and include them in the calculation
    * 1: exclude them from calculation
basis_type (0) 
    Determines which type of basis set to use
    * 0: B-splines
    * 1: Linear splines
pair_nonbonded_bspline_basis_order (4) 
    B-spline order used in pair non-bonded interaction basis sets
pair_bond_bspline_basis_order (4) 
    B-spline order used in pair bonded interaction basis sets
angle_bspline_basis_order (4) 
    B-spline order used in 1-3 bonded (angular) interaction basis sets
dihedral_bspline_basis_order (4) 
    B-spline order used in 1-4 bonded (dihedral) interaction basis sets
radius_of_gyration_bspline_basis_order (4) 
    B-spline order used in radius-of-gyration interaction basis sets
three_body_nonbonded_bspline_basis_order (4)    
    B-spline order used in three body non-bonded interactions basis sets
pair_nonbonded_basis_set_resolution (0.05)    
    The spacing between spline control points in pair non-bonded interaction basis sets
pair_bond_basis_set_resolution (0.05) 
    The spacing between spline control points in pair bonded interactions basis sets
angle_basis_set_resolution (0.05) 
    The spacing between spline control points in 1-3 bonded (angle) interaction basis sets
    This is either in distance units or degrees based on angle_type
dihedral_basis_set_resolution (0.05) 
    The spacing between spline control points in 1-4 bonded (dihedral) interaction basis 
    sets. This is either in distance units or degrees based on dihedral_type
dihedral_basis_set_resolution (1.0) 
    The spacing between spline control points in radius-of-gyration interaction basis 
    sets. This is either in distance units squared.
three_body_nonbonded_basis_set_resolution (1.0)    
    The spacing between spline control points in three body non-bonded interaction basis 
    sets. This is either in distance units or degrees based on angle_type
    Only used when three_body_nonbonded_style is positive
pair_nonbonded_output_binwidth (.05) 
    The spacing between tabulated force output for pair non-bonded interactions
pair_bond_output_binwidth (.05) 
    The spacing between tabulated force output for pair bonded interactions
angle_output_binwidth (.05) 
    The spacing between tabulated force output for 1-3 bonded (angle) interactions
    This is either in distance units or degrees based on angle_type
dihedral_output_binwidth (.05) 
    The spacing between tabulated force output for 1-4 bonded (dihedral) interactions
    This is either in distance units or degrees based on dihedral_type
radius_of_gyration_output_binwidth (1.0) 
    The spacing between tabulated force output for radius-of-gyration interactions.
    This is either in distance units squared
three_body_nonbonded_output_binwidth (.2) 
    The spacing between tabulated force output for three body non-bonded interactions
    This is either in distance units or degrees based on angle_type
    Only used when three_body_nonbonded_style is positive
rangefinder_thresholding_style (0)
	How to handle the sampling ranges reported by rangefinder
	* 0: report raw low/high values
	* -1: round range (to larger range) to integer multiple of fm_binwidth
	* -2: round range (to larger range) to integer multiple of output_binwidth 
	* 1: shrink range to first/last value that has 0.005% of total sampling.
	* 2: shrink range to first/last value that has 0.005% of the sampling for the most sampled bin.
	* 3: shrink range to first/last value that has at least 10 samples per bin.
	* 4: shrink range to first/last value that has at least 100 samples per bin.
	Note: For options 1 or 2 to work as intended, the appropriate output_*_parameter_distribution
	options must be enabled.
output_pair_nonbonded_parameter_distribution (0) 
    Whether or not to output the distribution of pair non-bonded distances sampled and 
    a histogram using the pair_nonbonded_basis_set_resolution as the binwidth 
    (rangefinder only)
    * 0: no
    * 1: yes
    * 2: yes and keep individual values in *.dist files
output_pair_bond_parameter_distribution (0) 
    Whether or not to output the distribution of pair bonded distances sampled and 
    a histogram using the pair_bond_basis_set_resolution as the binwidth 
    (rangefinder only)
    * 0: no
    * 1: yes
    * 2: yes and keep individual values in *.dist files
output_angle_parameter_distribution (0) 
    Whether or not to output the distribution of angles sampled and a histogram using 
    the angle_basis_set_resolution as the binwidth 
    (rangefinder only)
    * 0: no
    * 1: yes
    * 2: yes and keep individual values in *.dist files
output_dihedral_parameter_distribution (0) 
    Whether or not to output the distribution of dihedrals sampled and a histogram using 
    the dihedral_basis_set_resolution as the binwidth 
    (rangefinder only)
    * 0: no
    * 1: yes
    * 2: yes and keep individual values in *.dist files
output_radius_of_gyration_parameter_distribution (0) 
    Whether or not to output the distribution of radius-of-gyration sampled and a 
    histogram using the dihedral_basis_set_resolution as the binwidth 
    (rangefinder only)
    * 0: no
    * 1: yes
    * 2: yes and keep individual values in *.dist files
output_raw_frameblocks (0)
	Output matrix information for each frameblock in CSR format
	* 0: no
	* 1: yes
stillinger_weber_gamma (.12) 
    A fixed parameter for Stillinger-Weber type three body non-bonded interactions
    This determines the radial dependence of the interaction
    Only used when three_body_nonbonded_style is positive
matrix_type (0) 
    Determines which type of matrix equation the FM equations should be cast in
    * 0: dense block-accumulation and normal form equations
    * 1: sparse block-averaged equations (not recommended)
    * 2: block-accumulation equations (depricated -- no longer supported)
    * 3: sparse block-accumulation and dense normal form equations
    * 4: sparse block-accumulation and sparse normal form equations
itnlim (0) 
    Maximum number of iterations for refinement of sparse-matrix solver 
    Negative numbers cause iterations to be performed using quad-precision while positive 
    numbers cause iterations to be performed using double-precision
    Only for matrix_type 1 or 4
rcond (-1.0) 
    LSQR algorithm parameters for the sparse block-averaged force-matching
    This also controls the truncation of singular values if a positive number is specified 
    Only for dense-matrix solver matrix_type 0 and 3
sparse_safety_factor (0.2) 
    Fraction that sparse normal matrix should be oversized relative to actual size of 
    accumulated normal matrix after the previous frame-block
    Only for matrix_type 4
    If you encounter errors from mkl_dcsradd or mkl_dcsrmultcsr, it is likely that this 
    parameter needs to be increased
num_sparse_threads (1) 
    Number of threads that MKL routines can use 
    Only for matrix_type 1 and 4
    This number should be less than the number of physical cores for best performance
    However, using 1 thread may be faster than more threads in some cases
regularization_style (0) 
    Specifies the style of regularization
    * 0: no regularization
    * 1: scalar Tikhonov regularization specified using regularization_scalar
         This scalar squared is applied after preconditioning the normal matrix.
    * 2: vector Tikhonov regularization with vector from 'lambda.in'
         This file has one value per line with the number of lines equaling the
         number of basis functions
         This vector is applied as is to the normal matrix before preconditioning.
bayesian_mscg_flag (0)
    Whether or not to use the Bayesian MS-CG method
    This works for newfm matrix_types 0, 3, and 4 and combinefm matrix_type 0.
    * 0: no
    * 1: yes
	* 2: yes, also print out the normal matrix (once) and inverse matrix (each iteration)
bayesian_max_iterations (1)
    The number of iterations for the Bayesian MS-CG method.
    This is only used if bayesian_mscg_flag is 1.
    For each iteration the following outputs are generated:
        - The alpha vector is output to "alpha.out".
        - The beta value is output to "beta.out".
        - The residual is output to "residual.out".
        - The regularized normal matrix is output to "matrix.out"
        - The inverse of the regularized normal matrix is output to "inverse.out".
lanyuan_iterative_method_flag (0) 
    Whether or not to use Lanyuan's iterative FM method instead of the usual FM
    * 0: no 
    * 1: yes
primary_output_style (0) 
    Used to specify how this force-matching run's results should be used
    The binary matrix output is written to "result.out"
    * 0: output tabulated interactions
    * 2: output tables and binary representations of the blockwise matrix equations
    * 3: output only binary representations of the blockwise matrix equations
    	 do not solve for tables
    Note: The sparse matrix style (4) also outputs a human readable for of the matrix
          equations in CSR format in the file "result_csr.out". The first line lists
          the rows, columns, and number of entries. The next four lines list (in order):
          the values, the column indicies, the row sizes, and the RHS normal vector.
output_solution_flag (0) 
    Whether or not to print out the singular values of a dense or accumulation matrices
    * 0: no
    * 1: yes
output_residual_flag (0) 
    Whether or not to output the final MS-CG residual value
    This residual does not have any normalization (e.g., dimension * frames * sites)
    Note: This option only works for matrix_types 0, 3, and 4.
    * 0: no
    * 1: yes
output_spline_coeffs_flag (0) 
    Whether or not to output the final spline coefficients found from force-matching
    * 0: no
    * 1: yes 
output_normal_equations_rhs_flag (0) 
    Whether or not to output the right hand side of the final FM matrix equations
    * 0: no
    * 1: yes
temperature (300)
    This is used in determining values in Boltzmann inversion and relative entropy derivatives.
    Only used in newrem. It is in units of Kelvin.
boltzmann (0.0019872041)
    Used along with temperature for determining value in Boltzmann inversion and relative entropy derivatives.
    The default value assumes energy units of kcal/mol.
    The value needs to be adjusted so that the units match those of the interaction energy.
    Only used in newrem.
iteration_step_size (1.0)
     This is used in both relative entropy (newrem) and iterative force-matching (via newfm).
     * For newrem, it is the adjustable step size parameter used in the gradient decent 
     routine in newrem. 
     * For iterative force-matching, it control rates of convergence.
     Lower values imply a less aggressive fixed-point iteration.
     Only used when lanyuan_iterative_method_flag = 1
reference_input_style (0)
	What format information about the reference model is provided in.
	* 0: trajectory (usual command line options, e.g. -l_ref ref.lammpstrj)
	* 1: matrix from previous iteration (reference_matrix.out)
	* 2: distribution functions (i.e., RDFs for each interaction). 
	Note: Distribution functions can be generated from rangefinder using the 
	  output_*_parameter_distribution options.
cg_input_style (0)
	What format information about the (new) CG model is provided in.
	* 0: trajectory (usual command line options, e.g. -l_cg ref.lammpstrj)
	* 1: matrix from previous iteration (cg_matrix.out)
	* 2: distribution functions (i.e., RDFs for each interaction). 
	Note: Distribution functions can be generated from rangefinder using the 
	  output_*_parameter_distribution options.
	Note: when either cg or reference input style is 2, the other input_style must be 0. 
cg_observable_flag (0)
	Whether or not CG observable values are read in from observables.cg
	(only for recode.x)
	* 0: no
	* 1: yes

------------------------------------------------------------------------------------------

III.C) Interaction Determination
~~~~~~~~~~~~~~~~~~~~~

*Boltzmann inversion
*Force-Matching
*Relative entropy minimization
*Iterative Boltzmann inversion

III.C.1) Boltzmann inversion
============================

Using the executable "rangefinder.x", a Boltzmann inversion interaction can be determined.
This only requires the files necessary to run rangefinder.x.

To calculate a potential via Boltzmann inversion, set "primary_output_style" in "control.in"
to either 0 or 2. Also, for each interaction type that you desire, set the corresponding
output parameter distribution in "control.in" to 1 or 2 (e.g. output_pair_nonbonded_parameter_distribution).
For each interaction class that is turned on, the code will output tabulated force files
and basis set coefficients for each of the interactions. This can be very useful for 
zeroth iteration of relative entorpy minimization. For an example of how to use rangefinder.x 
for Boltzmann inversion, please see the "lammps_bi" sub-directory of the examples.

Note: The *.dat files here will contain potentials instead of forces.

III.C.2) Force-matching
=======================

After all of those files have been prepared, use newfm.x or a combination of newfm.x and 
combinefm.x to finish the force matching.

To use newfm.x, set "primary_output_style" in "control.in" to either 0 or 2. Then,
run the executable, and the code will output a tabulated force file for every interaction 
in the system, labeled by the CG site types involved and the interaction class 
(bon, dih, ang, etc).  These tabulated force files can be converted to the appropriate 
format for whatever simulation is desired.

To use a combination of newfm.x and combinefm.x, set "primary_output_style" in 
"control.in" to either 2 or 3. Run newfm.x on several different trajectories. After each
run of newfm.x, the code will output the final matrix equations for the trajectory that 
was provided to the executable. Then, create a file "res_av.in" that lists the number of 
matrix equation files on the first line, followed by each of their filenames on 
subsequent lines. For an example of how to use combinefm.x, please see the "batch_fm" 
sub-directory of the examples.

When one then runs combinefm.x, all of the matrix equations in those files will be 
combined, and tabulated forces based on all of these inputs will be the final result. 
The way that these inputs is process is the same way that the information from each 
"frame block" is combined with the information from other "frame blocks" (see the first 
reference for an explanation of this). This allows rudimentary batch-parallel force 
matching.

III.C.3) Relative entropy minimization
=====================================

Once all of the files have been prepared, newrem.x can be used to calculate interactions
via relatvie entropy minimization.

To use newrem.x, set "primary_output_style" in "control.in" to either 0 or 2. The executable
newrem.x expects two trajectories, a reference trajectory that is made from a mapped atomistic
trajectory (similar to the trajectory you would give to newfm.x) and a cg trajectory that is
simulated using either initial guess interactions or the iteractions provided by the previous
iteration of newrem.x. The executable also expects a file "b-spline-previous.out", which contains
the basis set coefficients used in creating the cg trajectory (using interactions generated via 
BI from rangefinder.x is recommended). After the executable is run, the code will output a 
tabulated force file for every interaction in the system, labeled by the CG site types involved 
and the interaction class (bon, dih, ang, etc). A simulation should be run using these interactions
for the next iteration of the entropy minimization. The lammps_rem example has a script that
can be used to perform multiple iterations. 

Note: The *.dat files here will contain potentials instead of forces.
Note: Forces are not needed in the input mapped trajectory.
Note: The reference information can be provided via distribution functions or a pre-processed
matrix using the reference_input_style.

III.C.4) Iterative Boltzmann inversion
============================

Once all of the files have been prepared, newibi.x can be used to calculate interactions
via iterative Boltzmann inversion.

To use newibi.x, set "primary_output_style" in "control.in" to either 0 or 2. The executable
newibi.x expects two trajectories, a reference trajectory that is made from a mapped atomistic
trajectory (similar to the trajectory you would give to newfm.x) and a cg trajectory that is
simulated using either initial guess interactions or the iteractions provided by the previous
iteration of newrem.x. The executable also expects a file "b-spline-previous.out", which contains
the basis set coefficients used in creating the cg trajectory (using interactions generated via 
BI from rangefinder.x is recommended). After the executable is run, the code will output a 
tabulated force file for every interaction in the system, labeled by the CG site types involved 
and the interaction class (bon, dih, ang, etc). A simulation should be run using these interactions
for the next iteration of the entropy minimization. The lammps_rem example has a script that
can be used to perform multiple iterations. 

Note: The *.dat files here will contain potentials instead of forces.
Note: Forces are not needed in the input mapped trajectory.
Note: The reference and cg information can be provided via distribution functions or a pre-processed
matrix using the reference_input_style.
Note: Only one model (reference or cg) can be input via distribution function at a time. 
When it is, the other model must be input via trajectory.

III.D) Check results
~~~~~~~~~~~~~~~~~~~~

III.D.1) Diagnostics and additional output
==========================================

In many cases, it is necessary to look at more than just the tabulated force output to 
determine if the results of force matching are reasonable. There are a number of output 
options designed to allow one to look deeper into the performance of the algorithm. 
In particular, the file 'sol_info.out' provides all of the singular values of the 
force-matching matrix, which can help determine if the problem is well-posed, 
the residual, which can indicate the relative quality of force fields with different 
choices of basis set, and the norm of the solution vector, which can indicate the spread 
of the spline coefficients and reveal outliers. The spline coefficients can also be output 
if desired by setting 'output_spline_coeffs_flag' = 1. 

III.D.2) Suggestions for optimal performance
============================================

Many of the strategies for improving the performance of MSCGFM are outlined in the 
reference at the top of this manual. Typically, we recommend starting with a dense-matrix-
based force-matching using the default parameters in control.in for the basis sets. If the 
condition number is too high after this, try using regularization. If that is not 
sufficient, explore whether the basis set resolution may be too high or too low; too high 
of a resolution will result in over-fitting, while too low will lead to significant 
correlation between nearby elements of the force-matching matrix, making the problem 
ill-posed when using the simple preconditioning currently implemented. Increasing or 
decreasing the order of splines used can have similar effects. If none of these improve 
performance, check that the basis set that you have chosen captures the essential 
physics of the model and consider adding a few more interactions, adding many-body 
interactions, or checking that the initial trajectory sampled enough phase space to come 
up with a reasonable model.

The choice of binwidth can be aided with the use of the "output_*_parameter_distribution" 
options. When this option is on, the rangefinder executable will output a list of each 
interaction value it encounters to a file specific to that interaction type. Additionally, 
a histogram will be generated from this data that uses the particular fm_binwidth for that 
interaction to determine the bin size. If there are not at least a few counts in each bin, 
you should either increase the binwidth or increase the number of frames.

The speed of the code may be improved by changing from matrix_type 0 to 3 or 4 if any of
the following conditions apply to your situation:
* There are many basis sets (at least 100)
* There are many different interactions (at least 10)
* Each frame has few particles (less than 100)
* Matrix solving takes more than 25% of overall run-time
Note: matrix_type 3 and 4 allow block_size > 1, which can further increase performance.

IV) Support for published papers
--------------------------------

The ordering and labeling of features and methods discussed follow the order that the 
papers were listed at the beginning of this manual.

1. If Izvekov's virial constraint is used, then a file 'p_con.in' must be provided 
   containing each frame's instantaneous value of the right-hand side of eq.(12) in 
   J. Chem. Phys. 123, 134105 (2005), i.e. 3*W(atom)+2*delta(E(kin)). Each value should 
   occupy its own line, so that the number of lines is equal to the number of frames in 
   the trajectory.
   
2. To use Bayesian MS-CG, one must set "bayesian_mscg_flag" to 1 and choose the desired
   number of iterations in "bayesian_max_iterations". The alpha and beta values described
   in this paper are calculated for each iteration and used to regularize the normal
   matrix in the next iteration. One should look for convergence of either alpha/beta or
   the solution elements as stopping criteria.

3. To use Stillinger-Weber-type three body interactions in MS-CG, one must perform two
	stages of force matching: one to determine the equilibrium angle, and then another to
	determine the interaction strength. In all cases, the top.in file should have a line 
	specifying the number of three body interactions (#) in the form "threebody #" followed
	by that number of lines, where each line lists the types involved in the interaction (t#),
	the theta_0 value and the cutoff distance (r_cut) in the format "t1 t2 t3 theta_0 r_cut".
	For the first run, set "three_body_nonbonded_style" to 2. Look at the output interaction 
	to determine the theta value. Then replace the cos_theta value in top.in with the
	appropriate value. For the second run, set "three_body_nonbonded_style" to 3. The interaction
	strength determined will be in 3b.dat.
	For a worked example, please look at the "threebody_fm" sub-directory of the
    examples.
    
4. To use iterative force matching, one must first run the code using 
   "primary_output_style 2" and "output_solution_flag 1". Then,rename result.out to 
   result.in and x.out to x.in.  Finally, use the "lanyuan_iterative_method_flag" and 
   "iteration_step_size" options in control.in when running the code again with
   the CG simulation as described in the reference. For additional iterations, copy the 
   new "result.out" to "result.in" and the new "x.out" to "x.in" before running the
   force matching code again with additional data.
   For a worked example, please look at the "iterative_fm" sub-directory of the examples.
    
5. To force match interactions between sites where the site's type changes during the 
   course of the simulation, use "dynamic_types 1". Make sure that mapped trajectory has
   the correct type assigned to it under the "type" field.
   Note: Dynamic types is only supported for LAMMPS trajectories.
   There is a worked example in the "ucg_lammps_fm_dynamic_type" sub-directory of the
   examples.

6. To create center-of-charge MS-CG models, apply the mapping described in J. Chem. Phys.,
   143, 243116 (2015) to the FG trajectory. Then, prepare all other inputs as usual.
 
7. There are two new methods described in J. Chem. Theory and Comput., 11(8), 3547–3560 
   (2015).
    a) MS-CG models can be constructed by reweighting frames at a different state-point or 
       from an enhanced sampling method using "use_statistical_reweighting". Any bias 
       forces must be subtracted from the trajectory before using this package. Also, a 
       file 'frame_weights.in' must be provided containing the weight that should be given 
       to each frame according to Eq. (4) in the paper. Each value should occupy its own 
       line. The number of lines is equal to the number of frames in the trajectory.
       For a worked example, please look at the "reweight_fm" sub-directory of the
       examples.
    Note: The UCG-I paper (J. Chem. Theory Comput. 9(5), 2466–2480 (2013). 
       doi:10.1021/ct4000444) describes conditions under which reweighting unnecessary. 
       In particular, frames from enhanced sampling (e.g. umbrella sampling, metadynamics) 
       where the bias is applied only to CG degrees-of-freedom (the mapped FG coordinates) 
       does not need reweighting. However, the bias forces still need to be subtracted 
       before using this package.
    b) This package provides support for the fitting of SCI and SCB sensitivity estimates. 
       The combined right-hand side of Eq. (5) or (7) should be combined into a single 
       trajectory where the result of that right-hand side is in place of the forces. 
       Then, run the package as usual.
 	The LAMMPS pair_styles used to run with these interactions are in the
	LAMMPS-ADD-ON repository.
	
8. This package provides support for the fitting of CG interactions as described in 
   J. Chem. Theory Comput., 12(5), 2144–2153 (2016). The frames generated using resulting 
   EDS potential can be used as input to this package. Then, run the package as usual.

9. The sampling issues related to states mentioned in doi: 10.1021/acs.jctc.6b01081
   are handled through the "dynamic_state_sampling" feature -- specified in control.in.
   This feature reads an extra column from the input trajectory (LAMMPS trajectory only)
   that contains the "state" probability. Then, the state for each of these particles
   is assigned between states 1 and 2 based on a random number (random_number_seed).
   This frame is resampled with different state assignments
   (dynamic_state_samples_per_frame).
      
10. The "local" density interactions in "Extending the Range and Physical Accuracy of
	Coarse-grained Models: Order Parameter Dependent Interactions " are described in 
	the "density supplement". This paper used the Lucy weight function 
	(density_interactions_flag 3) with a density_cutoff_distance of 10 A. Additionally, 
	this paper used a "global" wall interaction. This was parameterized by projecting the 
	system down to one dimension (x and fx only). Then, a one-dimensional version of the 
	code was complied (set the DIMENSION variable in the Makefile to 1) and run (with 
	position_dimension 1 in control.in).
	The LAMMPS pair_styles and fixes used to run with these interactions are in the
	LAMMPS-ADD-ON repository.
	
11. The observables in "Multiscale Compatible Observable Decomposition (MS-CODE) for 
	Coarse-grained Observable Representation" were fit using symmetric interaction
	(rmin*.in files "mode" is set to "sym") and one-body terms (one_body_flag 1). 
	Pressure was fit with everthing else as usual.
	Potential also required the use of scalar matching (scalar_matching_flag 1),
	and the potential is read from the "fx" column of the trajectory.
	The LAMMPS pair_styles used to run with these interactions are in the
	LAMMPS-ADD-ON repository.
